--- Wing colorscheme — Desktop config export
--- Generates matching theme configs for terminal emulators and desktop tools.
local M = {}

local palettes = require("wing.palettes")

--- Strip # from hex color
---@param hex string
---@return string
local function strip(hex)
  return hex:sub(2)
end

--- Hex to RGB tuple
---@param hex string
---@return number, number, number
local function hex_to_rgb(hex)
  hex = strip(hex)
  return tonumber(hex:sub(1, 2), 16), tonumber(hex:sub(3, 4), 16), tonumber(hex:sub(5, 6), 16)
end

--- Format RGB as "r, g, b"
---@param hex string
---@return string
local function rgb_str(hex)
  local r, g, b = hex_to_rgb(hex)
  return string.format("%d, %d, %d", r, g, b)
end

--- ANSI color names for readability
local ansi_names = {
  "black", "red", "green", "yellow", "blue", "magenta", "cyan", "white",
  "bright_black", "bright_red", "bright_green", "bright_yellow",
  "bright_blue", "bright_magenta", "bright_cyan", "bright_white",
}

--- Generate Ghostty config
---@param p table palette
---@param variant string
---@return string
function M.ghostty(p, variant)
  local lines = {
    "# Wing colorscheme — " .. variant,
    "# Generated by :WingExport",
    "",
    "background = " .. strip(p.bg),
    "foreground = " .. strip(p.fg),
    "cursor-color = " .. strip(p.accent),
    "cursor-text = " .. strip(p.bg),
    "selection-background = " .. strip(p.selection),
    "selection-foreground = " .. strip(p.fg),
    "",
  }
  for i, name in ipairs(ansi_names) do
    table.insert(lines, "palette = " .. (i - 1) .. "=" .. strip(p.terminal[i]))
  end
  return table.concat(lines, "\n") .. "\n"
end

--- Generate Kitty config
---@param p table palette
---@param variant string
---@return string
function M.kitty(p, variant)
  local lines = {
    "# Wing colorscheme — " .. variant,
    "# Generated by :WingExport",
    "",
    "background " .. p.bg,
    "foreground " .. p.fg,
    "cursor " .. p.accent,
    "cursor_text_color " .. p.bg,
    "selection_background " .. p.selection,
    "selection_foreground " .. p.fg,
    "url_color " .. p.accent_secondary,
    "",
  }
  local kitty_names = {
    "color0", "color1", "color2", "color3", "color4", "color5", "color6", "color7",
    "color8", "color9", "color10", "color11", "color12", "color13", "color14", "color15",
  }
  for i, name in ipairs(kitty_names) do
    table.insert(lines, name .. " " .. p.terminal[i])
  end
  return table.concat(lines, "\n") .. "\n"
end

--- Generate tmux config
---@param p table palette
---@param variant string
---@return string
function M.tmux(p, variant)
  return table.concat({
    "# Wing colorscheme — " .. variant,
    "# Generated by :WingExport",
    "# Source this file in tmux.conf",
    "",
    'set -g status-style "bg=' .. p.bg_alt .. ',fg=' .. p.fg_dim .. '"',
    'set -g window-status-current-style "bg=' .. p.bg .. ',fg=' .. p.accent .. ',bold"',
    'set -g window-status-style "bg=' .. p.bg_alt .. ',fg=' .. p.fg_muted .. '"',
    'set -g pane-border-style "fg=' .. p.border .. '"',
    'set -g pane-active-border-style "fg=' .. p.accent .. '"',
    'set -g message-style "bg=' .. p.bg_float .. ',fg=' .. p.fg .. '"',
    'set -g message-command-style "bg=' .. p.bg_float .. ',fg=' .. p.accent .. '"',
    'set -g mode-style "bg=' .. p.selection .. ',fg=' .. p.fg .. '"',
    'set -g copy-mode-match-style "bg=' .. p.accent .. ',fg=' .. p.bg .. '"',
    'set -g copy-mode-current-match-style "bg=' .. p.accent .. ',fg=' .. p.bg .. ',bold"',
  }, "\n") .. "\n"
end

--- Generate Hyprland color variables
---@param p table palette
---@param variant string
---@return string
function M.hyprland(p, variant)
  local lines = {
    "# Wing colorscheme — " .. variant,
    "# Generated by :WingExport",
    "# Source: source = ~/.config/hypr/wing-colors.conf",
    "",
    "$wing_bg = rgb(" .. strip(p.bg) .. ")",
    "$wing_bg_alt = rgb(" .. strip(p.bg_alt) .. ")",
    "$wing_bg_float = rgb(" .. strip(p.bg_float) .. ")",
    "$wing_fg = rgb(" .. strip(p.fg) .. ")",
    "$wing_fg_dim = rgb(" .. strip(p.fg_dim) .. ")",
    "$wing_fg_muted = rgb(" .. strip(p.fg_muted) .. ")",
    "$wing_accent = rgb(" .. strip(p.accent) .. ")",
    "$wing_accent_dim = rgb(" .. strip(p.accent_dim) .. ")",
    "$wing_accent_secondary = rgb(" .. strip(p.accent_secondary) .. ")",
    "$wing_error = rgb(" .. strip(p.error) .. ")",
    "$wing_warn = rgb(" .. strip(p.warn) .. ")",
    "$wing_info = rgb(" .. strip(p.info) .. ")",
    "$wing_border = rgb(" .. strip(p.border) .. ")",
    "$wing_border_focus = rgb(" .. strip(p.border_focus) .. ")",
    "$wing_selection = rgb(" .. strip(p.selection) .. ")",
    "",
    "# Usage example:",
    "# general {",
    "#     col.active_border = $wing_accent",
    "#     col.inactive_border = $wing_border",
    "# }",
  }
  return table.concat(lines, "\n") .. "\n"
end

--- Generate Waybar CSS variables
---@param p table palette
---@param variant string
---@return string
function M.waybar(p, variant)
  local lines = {
    "/* Wing colorscheme — " .. variant .. " */",
    "/* Generated by :WingExport */",
    "/* @import in your style.css */",
    "",
    "@define-color wing_bg " .. p.bg .. ";",
    "@define-color wing_bg_alt " .. p.bg_alt .. ";",
    "@define-color wing_bg_float " .. p.bg_float .. ";",
    "@define-color wing_fg " .. p.fg .. ";",
    "@define-color wing_fg_dim " .. p.fg_dim .. ";",
    "@define-color wing_fg_muted " .. p.fg_muted .. ";",
    "@define-color wing_accent " .. p.accent .. ";",
    "@define-color wing_accent_dim " .. p.accent_dim .. ";",
    "@define-color wing_accent_secondary " .. p.accent_secondary .. ";",
    "@define-color wing_error " .. p.error .. ";",
    "@define-color wing_warn " .. p.warn .. ";",
    "@define-color wing_info " .. p.info .. ";",
    "@define-color wing_border " .. p.border .. ";",
    "@define-color wing_selection " .. p.selection .. ";",
  }
  return table.concat(lines, "\n") .. "\n"
end

--- Generate JSON palette (for generic consumption)
---@param p table palette
---@param variant string
---@return string
function M.json(p, variant)
  -- Shallow copy without internal fields
  local out = {}
  for k, v in pairs(p) do
    if k:sub(1, 1) ~= "_" then
      out[k] = v
    end
  end
  return vim.json.encode(out) .. "\n"
end

--- Export targets and their file extensions
M.targets = {
  ghostty = { fn = M.ghostty, ext = "conf" },
  kitty = { fn = M.kitty, ext = "conf" },
  tmux = { fn = M.tmux, ext = "conf" },
  hyprland = { fn = M.hyprland, ext = "conf" },
  waybar = { fn = M.waybar, ext = "css" },
  json = { fn = M.json, ext = "json" },
}

--- Write a single export
---@param target string target name
---@param variant string "dark"|"light"
---@param dir string output directory
---@return string path written
function M.write(target, variant, dir)
  local t = M.targets[target]
  if not t then
    error("Unknown export target: " .. target)
  end

  local p = vim.deepcopy(variant == "dark" and palettes.dark or palettes.light)
  local content = t.fn(p, variant)
  local filename = "wing-" .. variant .. "." .. t.ext
  if target ~= "json" then
    filename = "wing-" .. variant .. "-" .. target .. "." .. t.ext
  end

  local path = vim.fs.joinpath(dir, filename)
  vim.fn.mkdir(dir, "p")

  local f = io.open(path, "w")
  if not f then
    error("Cannot write to: " .. path)
  end
  f:write(content)
  f:close()
  return path
end

--- Export all targets for both variants
---@param dir string output directory
---@return string[] paths written
function M.export_all(dir)
  local written = {}
  for target in pairs(M.targets) do
    for _, variant in ipairs({ "dark", "light" }) do
      table.insert(written, M.write(target, variant, dir))
    end
  end
  table.sort(written)
  return written
end

return M
